pipeline: acme_edw_tests
flowgroup: gold_layer_tests
description: Data quality tests for gold layer business aggregations

actions:
  # Test 1: Validate customer lifetime value calculations
  - name: test_customer_ltv_calculations
    type: test
    test_type: custom_sql
    source: "{catalog}.{gold_schema}.customer_lifetime_value"
    sql: |
      SELECT 
        customer_id,
        total_orders,
        total_revenue,
        avg_order_value,
        first_order_date,
        last_order_date
      FROM {catalog}.{gold_schema}.customer_lifetime_value
      WHERE total_orders > 0
    expectations:
      - name: valid_avg_order_value
        expression: "abs(avg_order_value - (total_revenue / total_orders)) < 0.01"
        on_violation: fail
      - name: positive_metrics
        expression: "total_orders > 0 AND total_revenue > 0"
        on_violation: fail
      - name: date_consistency
        expression: "first_order_date <= last_order_date"
        on_violation: fail
    description: "Validate customer lifetime value calculations are correct"

  # Test 2: Validate customer segmentation completeness
  - name: test_customer_segmentation_coverage
    type: test
    test_type: custom_sql
    source: "{catalog}.{gold_schema}.customer_segmentation_mv"
    sql: |
      WITH all_customers AS (
        SELECT DISTINCT customer_sk FROM {catalog}.{silver_schema}.customer_dim
      ),
      segmented_customers AS (
        SELECT DISTINCT customer_sk FROM {catalog}.{gold_schema}.customer_segmentation_mv
      )
      SELECT 
        (SELECT COUNT(*) FROM all_customers) as total_customers,
        (SELECT COUNT(*) FROM segmented_customers) as segmented_customers
    expectations:
      - name: all_customers_segmented
        expression: "total_customers = segmented_customers"
        on_violation: warn
    description: "Ensure all customers are included in segmentation"

  # Test 3: Validate executive dashboard metrics
  - name: test_executive_dashboard_consistency
    type: test
    test_type: custom_sql
    source: "{catalog}.{gold_schema}.executive_dashboard_mv"
    sql: |
      SELECT 
        reporting_date,
        total_revenue,
        total_orders,
        total_customers,
        avg_order_value
      FROM {catalog}.{gold_schema}.executive_dashboard_mv
      WHERE reporting_date >= dateadd(day, -30, current_date())
    expectations:
      - name: metrics_consistency
        expression: "abs(avg_order_value - (total_revenue / total_orders)) < 0.01"
        on_violation: fail
      - name: positive_counts
        expression: "total_orders >= 0 AND total_customers >= 0"
        on_violation: fail
    description: "Validate executive dashboard calculations"

  # Test 4: Product performance metrics validation
  - name: test_product_performance
    type: test
    test_type: custom_sql
    source: "{catalog}.{gold_schema}.product_performance_mv"
    sql: |
      SELECT 
        product_id,
        total_quantity_sold,
        total_revenue,
        avg_selling_price,
        profit_margin
      FROM {catalog}.{gold_schema}.product_performance_mv
    expectations:
      - name: valid_pricing
        expression: "avg_selling_price > 0 AND avg_selling_price = (total_revenue / total_quantity_sold)"
        on_violation: fail
      - name: reasonable_margins
        expression: "profit_margin >= -1.0 AND profit_margin <= 1.0"
        on_violation: warn
    description: "Validate product performance calculations"

  # Test 5: Ensure no orphaned records in materialized views
  - name: test_mv_referential_integrity
    type: test
    test_type: referential_integrity
    source: "{catalog}.{gold_schema}.customer_lifetime_value"
    reference: "{catalog}.{silver_schema}.customer_dim"
    source_columns: [customer_id]
    reference_columns: [c_custkey]
    on_violation: fail
    description: "All customers in gold layer must exist in silver dimensions"

  # Test 6: Revenue reconciliation between layers
  - name: test_revenue_reconciliation
    type: test
    test_type: custom_sql
    source: "{catalog}.{gold_schema}.executive_dashboard_mv"
    sql: |
      WITH silver_revenue AS (
        SELECT 
          DATE(o_orderdate) as order_date,
          SUM(l_extendedprice * (1 - l_discount)) as silver_total
        FROM {catalog}.{silver_schema}.lineitem_fct l
        JOIN {catalog}.{silver_schema}.orders_fct o ON l.l_orderkey = o.o_orderkey
        GROUP BY DATE(o_orderdate)
      ),
      gold_revenue AS (
        SELECT 
          reporting_date,
          total_revenue as gold_total
        FROM {catalog}.{gold_schema}.executive_dashboard_mv
      )
      SELECT 
        g.reporting_date,
        g.gold_total,
        s.silver_total,
        abs(g.gold_total - s.silver_total) as difference
      FROM gold_revenue g
      LEFT JOIN silver_revenue s ON g.reporting_date = s.order_date
      WHERE s.silver_total IS NOT NULL
    expectations:
      - name: revenue_matches
        expression: "difference < 0.01"
        on_violation: fail
    description: "Ensure revenue totals match between silver and gold layers"

  # Test 7: Date range validation for aggregations
  - name: test_aggregation_date_ranges
    type: test
    test_type: range
    source: "{catalog}.{gold_schema}.executive_dashboard_mv"
    column: reporting_date
    min_value: '2020-01-01'
    max_value: 'current_date()'
    on_violation: fail
    description: "Ensure dashboard dates are within expected range"
